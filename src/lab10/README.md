## Лаба №10

### Краткая теория

#### Стек (Stack) — LIFO

**Принцип:** Last In, First Out (последним пришёл — первым ушёл)

**Аналогия:** стопка тетрадей — можно взять только верхнюю

**Основные операции:**
- `push(x)` — положить элемент сверху → **O(1)**
- `pop()` — снять верхний элемент → **O(1)**
- `peek()` — посмотреть верхний, не снимая → **O(1)**
- `is_empty()` — проверка пустоты → **O(1)**

**Применения:**
- История действий (undo/redo в редакторах)
- Обход графа в глубину (DFS)
- Проверка сбалансированности скобок
- Вызов функций (call stack)


#### Очередь (Queue) — FIFO

**Принцип:** First In, First Out (первым пришёл — первым ушёл)

**Аналогия:** очередь в магазине — кто первый встал, тот первый обслуживается

**Основные операции:**
- `enqueue(x)` — добавить в конец очереди → **O(1)**
- `dequeue()` — взять из начала очереди → **O(1)**
- `peek()` — посмотреть первый элемент → **O(1)**
- `is_empty()` — проверка пустоты → **O(1)**

**Применения:**
- Обработка задач по очереди (task queue)
- Обход графа в ширину (BFS)
- Буферы (сетевые, файловые)
- Очереди сообщений

**Важно:** В Python `list.pop(0)` работает за **O(n)** (все элементы сдвигаются)
Для эффективной очереди используем `collections.deque`.ъ


#### Односвязный список (Singly Linked List)

**Структура:** последовательность узлов, где каждый узел хранит:
- `value` — значение элемента
- `next` — ссылку на следующий узел (или `None`)

**Визуализация:**
```
[1] -> [2] -> [3] -> None
```

**Преимущества:**
- Вставка/удаление в начале → **O(1)**
- Удаление из середины без сдвига элементов
- Динамический размер

**Недостатки:**
- Доступ по индексу → **O(n)** (нужно пройти от головы)
- Нет быстрого доступа к предыдущему элементу
- Больше памяти на хранение ссылок

**Основные операции:**
- `prepend(value)` — добавить в начало → **O(1)**
- `append(value)` — добавить в конец → **O(1)** (с tail) или **O(n)** (без tail)
- `insert(idx, value)` — вставка по индексу → **O(n)**
- `remove(value)` — удаление по значению → **O(n)**
- `remove_at(idx)` — удаление по индексу → **O(n)**


### Реализованные классы

#### 1. Stack (`src/lab10/structures.py`)

**Реализация:** на базе `list`, где вершина стека — `_data[-1]`

**Сложность всех операций:** O(1)


#### 2. Queue (`src/lab10/structures.py`)

**Реализация:** на базе `collections.deque` для сложности O(1) с обоих концов

**Сложность всех операций:** O(1)



#### 3. SinglyLinkedList (`src/lab10/linked_list.py`)

**Реализация:** с хранением `head`, `tail` и `_size`

**Сложность операций:**
- `prepend` → O(1)
- `append` → O(1)
- `insert` → O(n)
- `remove`, `remove_at` → O(n)
- итерация → O(n)


### Запуск демонстраций

#### Stack и Queue:
```bash
python3 -m src.lab10.structures
```
![Картинка 1](./images/lab10/structures.png)

#### SinglyLinkedList:
```bash
python3 -m src.lab10.linked_list
```
![Картинка 1](./images/lab10/linked_list.png)